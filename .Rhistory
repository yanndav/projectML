### STEP 3b: divide the cate estimates into Q tiles, and call this object G.
# Divide observations into n tiles
G <- data.frame(cate) %>% # replace cate with the name of your predictions object
ntile(Q) %>%  # Divide observations into Q-tiles
factor()
### STEP 4: Create a dataframe with Y, W (set B), D, G and p. Regress Y on group membership variables and covariates.
df <- cbind(Wb,data.frame(Y=Yb, D, G, p))
Wnames <- paste0('`',paste(colnames(Wb), collapse="+"),'`')
fml <- paste("Y ~",Wnames,"+ D:G")
model <- lm(fml, df, weights = 1/(p*(1-p)))
group_mean <- df %>%
select(-Y, -p,-D) %>%
filter(G==1 | G==Q) %>%
group_by(G) %>%
summarise_all(mean)
return(list("model" = model,
"clan"= group_mean))
}
output <- rerun(2, gates(data,line,response,treatment,controls))
## STEP 0: CREATE DATA VECTORS
data = drop_na(data[,c(paste0(line,response),treatment,controls)])
nrow(data)
Y = pull(data, paste0(line,response))
X = pull(data, treatment)
W = data[, controls]
### STEP 1: split the dataset into two sets, 1 and 2 (50/50)
split <- createFolds(1:length(Y), k=2)[[1]]
Ya = Y[split]
Yb = Y[-split]
Xa = X[split]
Xb = X[-split]
Wa = W[split, ]
Wb = W[-split, ]
p <- rep(mean(Xa), length(Xb))
### STEP 2b let D = W(set B) - propensity score.
D <- Xb-p
### STEP 3a: Get CATE (for example using xgboost) on set A. Predict on set B.
sl_y = SuperLearner(Y = Ya,
X = cbind(Wa,data.frame(X=Xa)),
family = gaussian(),
SL.library = "SL.xgboost",
cvControl = list(V=0))
pred_y1 = predict(sl_y, newdata=cbind(Wb,data.frame(X=ones(nrow(Wb)))))
pred_0s <- predict(sl_y, cbind(Wb,data.frame(X=zeros(nrow(Wb)))), onlySL = T)
pred_1s <- predict(sl_y, cbind(Wb,data.frame(X=ones(nrow(Wb)))), onlySL = T)
cate <- pred_1s$pred - pred_0s$pred
### STEP 3b: divide the cate estimates into Q tiles, and call this object G.
# Divide observations into n tiles
G <- data.frame(cate) %>% # replace cate with the name of your predictions object
ntile(Q) %>%  # Divide observations into Q-tiles
factor()
Q=4
### STEP 3b: divide the cate estimates into Q tiles, and call this object G.
# Divide observations into n tiles
G <- data.frame(cate) %>% # replace cate with the name of your predictions object
ntile(Q) %>%  # Divide observations into Q-tiles
factor()
### STEP 4: Create a dataframe with Y, W (set B), D, G and p. Regress Y on group membership variables and covariates.
df <- cbind(Wb,data.frame(Y=Yb, D, G, p))
Wnames <- paste0('`',paste(colnames(Wb), collapse="+"),'`')
fml <- paste("Y ~",Wnames,"+ D:G")
model <- lm(fml, df, weights = 1/(p*(1-p)))
fml
paste0('`',paste(colnames(Wb), collapse="+"),'`')
Wnames <- paste0('`',paste(colnames(Wb), collapse="`+`"),'`')
fml <- paste("Y ~",Wnames,"+ D:G")
model <- lm(fml, df, weights = 1/(p*(1-p)))
group_mean <- df %>%
select(-Y, -p,-D) %>%
filter(G==1 | G==Q) %>%
group_by(G) %>%
summarise_all(mean)
# Removes all identifiers
remove = c('id','idno','pid','branch_name')
controls = setdiff(variables_labels$V1, c(treatment,
paste0(rep(lines,1,
each = length(responses)),
responses),
remove))
length(controls)# 58 variables selected
## STEP 0: CREATE DATA VECTORS
data = drop_na(data[,c(paste0(line,response),treatment,controls)])
nrow(data)
Y = pull(data, paste0(line,response))
X = pull(data, treatment)
W = data[, controls]
### STEP 1: split the dataset into two sets, 1 and 2 (50/50)
split <- createFolds(1:length(Y), k=2)[[1]]
Ya = Y[split]
Yb = Y[-split]
Xa = X[split]
Xb = X[-split]
Wa = W[split, ]
Wb = W[-split, ]
p <- rep(mean(Xa), length(Xb))
### STEP 2b let D = W(set B) - propensity score.
D <- Xb-p
### STEP 3a: Get CATE (for example using xgboost) on set A. Predict on set B.
sl_y = SuperLearner(Y = Ya,
X = cbind(Wa,data.frame(X=Xa)),
family = gaussian(),
SL.library = "SL.xgboost",
cvControl = list(V=0))
pred_y1 = predict(sl_y, newdata=cbind(Wb,data.frame(X=ones(nrow(Wb)))))
pred_0s <- predict(sl_y, cbind(Wb,data.frame(X=zeros(nrow(Wb)))), onlySL = T)
pred_1s <- predict(sl_y, cbind(Wb,data.frame(X=ones(nrow(Wb)))), onlySL = T)
cate <- pred_1s$pred - pred_0s$pred
### STEP 3b: divide the cate estimates into Q tiles, and call this object G.
# Divide observations into n tiles
G <- data.frame(cate) %>% # replace cate with the name of your predictions object
ntile(Q) %>%  # Divide observations into Q-tiles
factor()
### STEP 4: Create a dataframe with Y, W (set B), D, G and p. Regress Y on group membership variables and covariates.
df <- cbind(Wb,data.frame(Y=Yb, D, G, p))
Wnames <- paste0('`',paste(colnames(Wb), collapse="`+`"),'`')
fml <- paste("Y ~",Wnames,"+ D:G")
model <- lm(fml, df, weights = 1/(p*(1-p)))
group_mean <- df %>%
select(-Y, -p,-D) %>%
filter(G==1 | G==Q) %>%
group_by(G) %>%
summarise_all(mean)
# Loading cleaned dataset
data = read_dta('ELA.dta')
output <- rerun(2, gates(data,line,response,treatment,controls))
gates <- function(data,line,response,treatment,controls, Q=4, prop_scores=F) {
## STEP 0: CREATE DATA VECTORS
data = drop_na(data[,c(paste0(line,response),treatment,controls)])
nrow(data)
Y = pull(data, paste0(line,response))
X = pull(data, treatment)
W = data[, controls]
### STEP 1: split the dataset into two sets, 1 and 2 (50/50)
split <- createFolds(1:length(Y), k=2)[[1]]
Ya = Y[split]
Yb = Y[-split]
Xa = X[split]
Xb = X[-split]
Wa = W[split, ]
Wb = W[-split, ]
### STEP 2a: (Propensity score) On set A, train a model to predict X using W. Predict on set B.
if (prop_scores==T) {
sl_w1 = SuperLearner(Y = Xa,
X = Wa,
newX = Wb,
family = binomial(),
SL.library = "SL.xgboost",
cvControl = list(V=0))
p <- sl_w1$SL.predict
} else {
p <- rep(mean(Xa), length(Xb))
}
### STEP 2b let D = W(set B) - propensity score.
D <- Xb-p
### STEP 3a: Get CATE (for example using xgboost) on set A. Predict on set B.
sl_y = SuperLearner(Y = Ya,
X = cbind(Wa,data.frame(X=Xa)),
family = gaussian(),
SL.library = "SL.xgboost",
cvControl = list(V=0))
pred_y1 = predict(sl_y, newdata=cbind(Wb,data.frame(X=ones(nrow(Wb)))))
pred_0s <- predict(sl_y, cbind(Wb,data.frame(X=zeros(nrow(Wb)))), onlySL = T)
pred_1s <- predict(sl_y, cbind(Wb,data.frame(X=ones(nrow(Wb)))), onlySL = T)
cate <- pred_1s$pred - pred_0s$pred
### STEP 3b: divide the cate estimates into Q tiles, and call this object G.
# Divide observations into n tiles
G <- data.frame(cate) %>% # replace cate with the name of your predictions object
ntile(Q) %>%  # Divide observations into Q-tiles
factor()
### STEP 4: Create a dataframe with Y, W (set B), D, G and p. Regress Y on group membership variables and covariates.
df <- cbind(Wb,data.frame(Y=Yb, D, G, p))
Wnames <- paste0('`',paste(colnames(Wb), collapse="`+`"),'`')
fml <- paste("Y ~",Wnames,"+ D:G")
model <- lm(fml, df, weights = 1/(p*(1-p)))
group_mean <- df %>%
select(-Y, -p,-D) %>%
filter(G==1 | G==Q) %>%
group_by(G) %>%
summarise_all(mean)
return(list("model" = model,
"clan"= group_mean))
}
output <- rerun(2, gates(data,line,response,treatment,controls))
table = lapply(1:length(output),
function(k) table_from_gates(output[[k]][["model"]]))%>%
bind_rows %>%
group_by(coefficient) %>%
summarize_all(median)
table
table_from_gates <-function(model) {
thetahat <- model%>%
.$coefficients %>%
.[c("D:G1","D:G2","D:G3","D:G4")]
# Confidence intervals
cihat <- confint(model)[c("D:G1","D:G2","D:G3","D:G4"),]
res <- tibble(Coefficient = c("gamma1","gamma2","gamma3","gamma4"),
Estimates = thetahat,
'Lower Bound 90%' = cihat[,1],
'Upper Bound 90%' = cihat[,2])
return(res)
}
table = lapply(1:length(output),
function(k) table_from_gates(output[[k]][["model"]]))%>%
bind_rows %>%
group_by(Coefficient) %>%
summarize_all(median)
table
table_from_gates <-function(model) {
thetahat <- model%>%
.$coefficients %>%
.[c("D:G1","D:G2","D:G3","D:G4")]
# Confidence intervals
cihat <- confint(model)[c("D:G1","D:G2","D:G3","D:G4"),]
res <- tibble(Coefficient = c("Gamma1","Gamma2","Gamma3","Gamma4"),
Estimates = thetahat,
'Lower Bound 90%' = cihat[,1],
'Upper Bound 90%' = cihat[,2])
return(res)
}
table = lapply(1:length(output),
function(k) table_from_gates(output[[k]][["model"]]))%>%
bind_rows %>%
group_by(Coefficient) %>%
summarize_all(median)
table
for(name in names(resultBLP)){
title =  cleanTitle(name,add="Best Linear Predictor for ")
print(title)
table = kable(resultBLP[[name]], "latex",caption=title,label=name,booktabs = T)
writeLines(table,con=paste0(name,'.tex'))
}
output
resultGATES[[name]][['tableGATES']]
name
resultGATES[[name]]
rereunParam = 2
resultGATES = list()
for(line in lines){
for(response in responses){
print(response)
resultGATES[[paste0(line,response)]][["raw"]] <- rerun(rereunParam, gates(data,line,response,treatment,controls))
resultGATES[[paste0(line,response)]][['tableGATES']] = lapply(1:length(resultGATES[[paste0(line,response)]][["raw"]]),
function(k) table_from_gates(resultGATES[[paste0(line,response)]][["raw"]][[k]][["model"]]))%>%
bind_rows %>%
group_by(coefficient) %>%
summarize_all(median)
resultGATES[[paste0(line,response)]][['clan']] = lapply(1:length(resultGATES[[paste0(line,response)]][["raw"]]),
function(k) resultGATES[[paste0(line,response)]][["raw"]][[k]][["clan"]])%>%
bind_rows %>%
group_by(G) %>%
summarize_all(median)
}
}
resultGATES = list()
for(line in lines){
for(response in responses){
print(response)
resultGATES[[paste0(line,response)]][["raw"]] <- rerun(rereunParam, gates(data,line,response,treatment,controls))
resultGATES[[paste0(line,response)]][['tableGATES']] = lapply(1:length(resultGATES[[paste0(line,response)]][["raw"]]),
function(k) table_from_gates(resultGATES[[paste0(line,response)]][["raw"]][[k]][["model"]]))%>%
bind_rows %>%
group_by(Coefficient) %>%
summarize_all(median)
resultGATES[[paste0(line,response)]][['clan']] = lapply(1:length(resultGATES[[paste0(line,response)]][["raw"]]),
function(k) resultGATES[[paste0(line,response)]][["raw"]][[k]][["clan"]])%>%
bind_rows %>%
group_by(G) %>%
summarize_all(median)
}
}
names(resultGATES)
cleanTitle(name,add="Sorted Group Average Treatment Effects for ")
resultGATES[[name]][['tableGATES']]
resultGATES[[name]][['clan']]
t(resultGATES[[name]][['clan']])
?as.data.frame
as.data.frame(t(resultGATES[[name]][['clan']]))
resultGATES[[name]][['clan']][1,]
resultGATES[[name]][['clan']][,1]
as.data.frame(t(resultGATES[[name]][['clan']])[2:nncol(resultGATES[[name]][['clan']])],
col.names = resultGATES[[name]][['clan']][,1])
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']])],
col.names = resultGATES[[name]][['clan']][,1])
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),],
col.names = resultGATES[[name]][['clan']][,1])
as.character(resultGATES[[name]][['clan']][,1])
apply(resultGATES[[name]][['clan']][,1]),as.character)
apply(resultGATES[[name]][['clan']][,1],as.character)
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),],
col.names = c("1","4"))
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("1"=V1)
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs(G1-G4)/min(c(G1,G4)))
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs(G1-G4)/G1)
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1))
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1),
rank = rank(diff))
?rank
?sort
?order
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1),
rank = sort(diff,decreasing = T))
as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1),
rank = n()-rank(diff))
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1),
rank = n()-rank(diff))
View(clan_df)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
diff = abs((G1-G4)/G1),
rank = n()-rank(diff)) %>%
filter(rank<=10)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
"Abs. Perc. Difference" = abs((G1-G4)/G1),
rank = n()-rank("Abs. Perc. Difference")) %>%
filter(rank<=10) %>%
select(-rank)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("G1"=V1,
"G4"=V2) %>%
mutate(G1=as.numeric(G1),
G4=as.numeric(G4),
"Abs. Perc. Difference" = abs((G1-G4)/G1),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
filter(rank<=10) %>%
select(-rank)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("Group 1"=V1,
"Group 4"=V2) %>%
mutate(`Group 1`=as.numeric(`Group 1`),
`Group 1`=as.numeric(`Group 4`),
"Abs. Perc. Difference" = abs((`Group 1`-`Group 4`)/`Group 1`),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
filter(rank<=10) %>%
select(-rank)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
rename("Group 1"=V1,
"Group 4"=V2) %>%
mutate(`Group 1`=as.numeric(`Group 1`),
`Group 1`=as.numeric(`Group 4`),
test = abs((`Group 1`-`Group 4`)/`Group 1`),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
filter(rank<=10) %>%
select(-rank)
clan_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
mutate(V1=as.numeric(V1),
V2=as.numeric(V2),
"Abs. Perc. Difference" = abs((V1-V2)/V1),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
rename("Group 1"=V1,
"Group 4"=V2) %>%
filter(rank<=10) %>%
select(-rank)
for(name in names(resultBLP)){
title =  cleanTitle(name,add="Best Linear Predictor for ")
print(title)
table = kable(resultBLP[[name]], "latex",caption=title,label=paste0("blp",name),booktabs = T)
writeLines(table,con=paste0("BLP_",name,'.tex'))
}
for(name in names(resultGATES)){
# GATES
title =  cleanTitle(name,add="Sorted Group Average Treatment Effects for ")
print(title)
table = kable(resultGATES[[name]][['tableGATES']], "latex",caption=title,label=paste0("gates",name),booktabs = T)
writeLines(table,con=paste0('GATES_',name,'.tex'))
# CLAN
CLAN_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
mutate(V1=as.numeric(V1),
V2=as.numeric(V2),
"Abs. Perc. Difference" = abs((V1-V2)/V1),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
rename("Group 1"=V1,
"Group 4"=V2) %>%
filter(rank<=10) %>%
select(-rank)
titleCLAN =  cleanTitle(name,add="Classification Analysis for ")
print(title)
table = kable(CLAN_df, "latex",caption=titleCLAN,label=paste0("clan",name),booktabs = T)
writeLines(tableCLAN,con=paste0('CLAN_',name,'.tex'))
}
for(name in names(resultGATES)){
# GATES
title =  cleanTitle(name,add="Sorted Group Average Treatment Effects for ")
print(title)
table = kable(resultGATES[[name]][['tableGATES']], "latex",caption=title,label=paste0("gates",name),booktabs = T)
writeLines(table,con=paste0('GATES_',name,'.tex'))
# CLAN
CLAN_df = as.data.frame(t(resultGATES[[name]][['clan']])[2:ncol(resultGATES[[name]][['clan']]),]) %>%
mutate(V1=as.numeric(V1),
V2=as.numeric(V2),
"Abs. Perc. Difference" = abs((V1-V2)/V1),
rank = n()-rank(`Abs. Perc. Difference`)) %>%
rename("Group 1"=V1,
"Group 4"=V2) %>%
filter(rank<=10) %>%
select(-rank)
titleCLAN =  cleanTitle(name,add="Classification Analysis for ")
print(titleCLAN)
tableCLAN = kable(CLAN_df, "latex",caption=titleCLAN,label=paste0("clan",name),booktabs = T)
writeLines(tableCLAN,con=paste0('CLAN_',name,'.tex'))
}
url = "https://raw.githubusercontent.com/yanndav/projectML/main/output/"
methods = c("BLP","GATES","CLAN")
lines = c('R','Q')
responses = c('Entrep_total',
"any_iga" ,
"selfempl",
"empl",
"Expenditure_totDF")
print(paste0(url,method,'_',line,reponse,'.tex'))
url = "https://raw.githubusercontent.com/yanndav/projectML/main/output/"
methods = c("BLP","GATES","CLAN")
lines = c('R','Q')
responses = c('Entrep_total',
"any_iga" ,
"selfempl",
"empl",
"Expenditure_totDF")
for(method in methods){
for (line in lines) {
for response in responses{
print(paste0(url,method,'_',line,reponse,'.tex'))
}
}
}
for(method in methods){
for (line in lines) {
for response in responses{
print(paste0(url,method,'_',line,reponse,'.tex'))
}
}
}
for(method in methods){
for (line in lines) {
for( response in responses){
print(paste0(url,method,'_',line,reponse,'.tex'))
}
}
}
for(method in methods){
for (line in lines) {
for( response in responses){
print(paste0(url,method,'_',line,reponse,'.tex'))
}
}
}
url = "https://raw.githubusercontent.com/yanndav/projectML/main/output/"
methods = c("BLP","GATES","CLAN")
lines = c('R','Q')
responses = c('Entrep_total',
"any_iga" ,
"selfempl",
"empl",
"Expenditure_totDF")
for(method in methods){
for (line in lines) {
for(response in responses){
print(paste0(url,method,'_',line,reponse,'.tex'))
}
}
}
responses
line
for(method in methods){
for (line in lines) {
for(response in responses){
print(paste0(url,method,'_',line,response,'.tex'))
}
}
}
